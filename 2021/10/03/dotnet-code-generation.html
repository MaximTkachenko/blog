<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Dotnet code generation overview by example | Software engineering blog without title</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc.">
<meta name="author" content="">
<link rel="canonical" href="https://mtkachenko.me/blog/2021/10/03/dotnet-code-generation.html">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://mtkachenko.me/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mtkachenko.me/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mtkachenko.me/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mtkachenko.me/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://mtkachenko.me/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://mtkachenko.me/blog/2021/10/03/dotnet-code-generation.html">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Dotnet code generation overview by example" />
<meta property="og:description" content="Introduction Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mtkachenko.me/blog/2021/10/03/dotnet-code-generation.html" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-03T11:11:11+00:00" />
<meta property="article:modified_time" content="2021-10-03T11:11:11+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dotnet code generation overview by example"/>
<meta name="twitter:description" content="Introduction Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mtkachenko.me/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Dotnet code generation overview by example",
      "item": "https://mtkachenko.me/blog/2021/10/03/dotnet-code-generation.html"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Dotnet code generation overview by example",
  "name": "Dotnet code generation overview by example",
  "description": "Introduction Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc.",
  "keywords": [
    
  ],
  "articleBody": "Introduction Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc. Now when I have a sufficient understanding of the topic I realized that in the past I had some tasks which could be solved in more efficient and elegant way by using code generation. Unfortunately during those times I knew nothing about it. Searching the internet gave me results with quite high entry threshold and they didn’t give an entire understanding of the feature. Most of examples in articles are quite trivial so it’s still unclear how to apply it in practice. Here as the first step I want to describe a particular problem which could be solved with metaprogramming and then to give an overview of different code generation approaches. There will be a lot of code.\nTask description Let’s imagine our application receives a data from some source as an array of strings (for simplicity only string, integer and datetime values are expected in an input array):\n[\"John McClane\", \"1994-11-05T13:15:30\", \"4455\"] I need a generic way to parse this input into the instance of a particular class. This is an interface to create a parser delegate (i.e. it accepts an array of strings as the input and returns an instance of T as the output):\npublic interface IParserFactory { Func\u003cstring[], T\u003e GetParser() where T : new(); } I use ParserOutputAttribute to identify classes used as parser’s output. And I use ArrayIndexAttribute to understand which property corresponds to each of the array elements:\n[ParserOutput] public class Data { [ArrayIndex(0)] public string Name { get; set; } // will be \"John McClane\" [ArrayIndex(2)] public int Number { get; set; } // will be 4455 [ArrayIndex(1)] public DateTime Birthday { get; set; } // will be 1994-11-05T13:15:30 } If array element can’t be parsed to the target type then it’s ignored. So as a general idea I don’t want to limit implementation by Data class only. I want to produce a parser delegate for any type with the proper attributes.\nPlain C# First of all I want to write a plain C# code without code generation or reflection at all for a known type:\nvar data = new Data(); if (0 \u003c inputArray.Length) { data.Name = inputArray[0]; } if (1 \u003c inputArray.Length \u0026\u0026 DateTime.TryParse(inputArray[1], out var bd)) { data.Birthday = bd; } if (2 \u003c inputArray.Length \u0026\u0026 int.TryParse(inputArray[2], out var n)) { data.Number = n; } return data; Quite simple, right? But now I want to generate the same code for an arbitrary type at runtime or compile time. Let’s go!\nReflection In the first approach with reflection I’m not going to generate a parser delegate. Instead I’m going to create an instance of the target type and set its properties using reflection API.\npublic class ReflectionParserFactory : IParserFactory { public Func\u003cstring[], T\u003e GetParser() where T : new() { return ArrayIndexParse; } private static T ArrayIndexParse(string[] data) where T : new() { // create a new instance of target type var instance = new T(); var props = typeof(T).GetProperties(BindingFlags.Instance | BindingFlags.Public); //go through all public and non-static properties //read and parse corresponding element in array and if success - set property value for (int i = 0; i \u003c props.Length; i++) { var attrs = props[i].GetCustomAttributes(typeof(ArrayIndexAttribute)).ToArray(); if (attrs.Length == 0) continue; int order = ((ArrayIndexAttribute)attrs[0]).Order; if (order \u003c 0 || order \u003e= data.Length) continue; if (props[i].PropertyType == typeof(string)) { props[i].SetValue(instance, data[order]); continue; } if (props[i].PropertyType == typeof(int)) { if (int.TryParse(data[order], out var intResult)) { props[i].SetValue(instance, intResult); } continue; } if (props[i].PropertyType == typeof(DateTime)) { if (DateTime.TryParse(data[order], out var dtResult)) { props[i].SetValue(instance, dtResult); } } } return instance; } } It works and it’s quite readable. But it’s slow (check benchmarks section below too). If you want to call this code very often it could be an issue. I want to implement something more sophisticated using real code generation.\nCode generation Expression trees From the official documentation:\nExpression trees represent code in a tree-like data structure, where each node is an expression, for example, a method call or a binary operation such as x \u003c y. You can compile and run code represented by expression trees.\nHow to execute expression trees Expression classes Expression trees give primitive building blocks like Expression.Call to call a method, Expression.Loop to add some repeating logic etc. Then using these blocks we build a parser delegate as a tree of instructions and finally compile it into the delegate at runtime.\npublic class ExpressionTreeParserFactory : IParserFactory { public Func\u003cstring[], T\u003e GetParser() where T : new() { var props = typeof(T).GetProperties(BindingFlags.Instance | BindingFlags.Public); //declare an input parameter of the delegate ParameterExpression inputArray = Expression.Parameter(typeof(string[]), \"inputArray\"); //declare an output parameter of the delegate ParameterExpression instance = Expression.Variable(typeof(T), \"instance\"); //create a new instance of target type var block = new List { Expression.Assign(instance, Expression.New(typeof(T).GetConstructors()[0])) }; var variables = new List {instance}; //go through all public and non-static properties foreach (var prop in props) { var attrs = prop.GetCustomAttributes(typeof(ArrayIndexAttribute)).ToArray(); if (attrs.Length == 0) continue; int order = ((ArrayIndexAttribute)attrs[0]).Order; if (order \u003c 0) continue; //validate an index from ArrayIndexAttribute var orderConst = Expression.Constant(order); var orderCheck = Expression.LessThan(orderConst, Expression.ArrayLength(inputArray)); if (prop.PropertyType == typeof(string)) { //set string property var stringPropertySet = Expression.Assign( Expression.Property(instance, prop), Expression.ArrayIndex(inputArray, orderConst)); block.Add(Expression.IfThen(orderCheck, stringPropertySet)); continue; } //get parser method from the list of available parsers (currently we parse only Int and DateTime) if (!TypeParsers.Parsers.TryGetValue(prop.PropertyType, out var parser)) { continue; } var parseResult = Expression.Variable(prop.PropertyType, \"parseResult\"); var parserCall = Expression.Call(parser, Expression.ArrayIndex(inputArray, orderConst), parseResult); var propertySet = Expression.Assign( Expression.Property(instance, prop), parseResult); //set property if an element of array is successfully parsed var ifSet = Expression.IfThen(parserCall, propertySet); block.Add(Expression.IfThen(orderCheck, ifSet)); variables.Add(parseResult); } block.Add(instance); //compile lambda expression into delegate return Expression.Lambda",
  "wordCount" : "2575",
  "inLanguage": "en",
  "datePublished": "2021-10-03T11:11:11Z",
  "dateModified": "2021-10-03T11:11:11Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mtkachenko.me/blog/2021/10/03/dotnet-code-generation.html"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Software engineering blog without title",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mtkachenko.me/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mtkachenko.me/blog/" accesskey="h" title="Software engineering blog without title (Alt + H)">Software engineering blog without title</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Dotnet code generation overview by example
    </h1>
    <div class="post-meta"><span title='2021-10-03 11:11:11 +0000 UTC'>October 3, 2021</span>

</div>
  </header> 
  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc. Now when I have a sufficient understanding of the topic I realized that in the past I had some tasks which could be solved in more efficient and elegant way by using code generation. Unfortunately during those times I knew nothing about it. Searching the internet gave me results with quite high entry threshold and they didn&rsquo;t give an entire understanding of the feature. Most of examples in articles are quite trivial so it&rsquo;s still unclear how to apply it in practice. Here as the first step I want to describe a particular problem which could be solved with <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> and then to give an overview of different code generation approaches. There will be a lot of code.</p>
<h2 id="task-description">Task description<a hidden class="anchor" aria-hidden="true" href="#task-description">#</a></h2>
<p>Let&rsquo;s imagine our application receives a data from some source as an array of strings (for simplicity only string, integer and datetime values are expected in an input array):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>[<span style="color:#e6db74">&#34;John McClane&#34;</span>, <span style="color:#e6db74">&#34;1994-11-05T13:15:30&#34;</span>, <span style="color:#e6db74">&#34;4455&#34;</span>]
</span></span></code></pre></div><p>I need a generic way to parse this input into the instance of a particular class. This is an interface to create a parser delegate (i.e. it accepts an array of strings as the input and returns an instance of <code>T</code> as the output):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IParserFactory</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I use <code>ParserOutputAttribute</code> to identify classes used as parser&rsquo;s output. And I use <code>ArrayIndexAttribute</code> to understand which property corresponds to each of the array elements:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[ParserOutput]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Data</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [ArrayIndex(0)]</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } <span style="color:#75715e">// will be &#34;John McClane&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [ArrayIndex(2)]</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Number { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } <span style="color:#75715e">// will be 4455</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [ArrayIndex(1)]</span> <span style="color:#66d9ef">public</span> DateTime Birthday { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } <span style="color:#75715e">// will be 1994-11-05T13:15:30</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If array element can&rsquo;t be parsed to the target type then it&rsquo;s ignored.
So as a general idea I don&rsquo;t want to limit implementation by <code>Data</code> class only. I want to produce a parser delegate for any type with the proper attributes.</p>
<h2 id="plain-c">Plain C#<a hidden class="anchor" aria-hidden="true" href="#plain-c">#</a></h2>
<p>First of all I want to write a plain C# code without code generation or reflection at all for a known type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> data = <span style="color:#66d9ef">new</span> Data();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> &lt; inputArray.Length)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    data.Name = inputArray[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">1</span> &lt; inputArray.Length &amp;&amp; DateTime.TryParse(inputArray[<span style="color:#ae81ff">1</span>], <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> bd))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    data.Birthday = bd;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">2</span> &lt; inputArray.Length &amp;&amp; <span style="color:#66d9ef">int</span>.TryParse(inputArray[<span style="color:#ae81ff">2</span>], <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> n))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    data.Number = n;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> data;
</span></span></code></pre></div><p>Quite simple, right? But now I want to generate the same code for an arbitrary type at runtime or compile time. Let&rsquo;s go!</p>
<h2 id="reflection">Reflection<a hidden class="anchor" aria-hidden="true" href="#reflection">#</a></h2>
<p>In the first approach with <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection">reflection</a> I&rsquo;m not going to generate a parser delegate. Instead I&rsquo;m going to create an instance of the target type and set its properties using reflection API.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReflectionParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ArrayIndexParse&lt;T&gt;;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> T ArrayIndexParse&lt;T&gt;(<span style="color:#66d9ef">string</span>[] data) <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// create a new instance of target type</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> instance = <span style="color:#66d9ef">new</span> T();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> props = <span style="color:#66d9ef">typeof</span>(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all public and non-static properties</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//read and parse corresponding element in array and if success - set property value</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; props.Length; i++)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> attrs = props[i].GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span> || order &gt;= data.Length) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (props[i].PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				props[i].SetValue(instance, data[order]);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (props[i].PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">int</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">int</span>.TryParse(data[order], <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> intResult))
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					props[i].SetValue(instance, intResult);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (props[i].PropertyType == <span style="color:#66d9ef">typeof</span>(DateTime))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (DateTime.TryParse(data[order], <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> dtResult))
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					props[i].SetValue(instance, dtResult);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> instance;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It works and it&rsquo;s quite readable. But it&rsquo;s <a href="https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/">slow</a> (check <a href="#benchmarks">benchmarks</a> section below too). If you want to call this code very often it could be an issue. I want to implement something more sophisticated using <strong>real</strong> code generation.</p>
<h2 id="code-generation">Code generation<a hidden class="anchor" aria-hidden="true" href="#code-generation">#</a></h2>
<h3 id="expression-trees">Expression trees<a hidden class="anchor" aria-hidden="true" href="#expression-trees">#</a></h3>
<p>From the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/">official documentation</a>:</p>
<blockquote>
<p>Expression trees represent code in a tree-like data structure, where each node is an expression, for example, a method call or a binary operation such as x &lt; y. You can compile and run code represented by expression trees.</p>
</blockquote>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-execute-expression-trees">How to execute expression trees</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions?view=netcore-3.1#classes">Expression classes</a></li>
</ul>
<p>Expression trees give primitive building blocks like <code>Expression.Call</code> to call a method, <code>Expression.Loop</code> to add some repeating logic etc. Then using these blocks we build a parser delegate as a <code>tree</code> of instructions and finally compile it into the delegate at runtime.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExpressionTreeParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> props = <span style="color:#66d9ef">typeof</span>(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//declare an input parameter of the delegate</span>
</span></span><span style="display:flex;"><span>		ParameterExpression inputArray = Expression.Parameter(<span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>[]), <span style="color:#e6db74">&#34;inputArray&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//declare an output parameter of the delegate</span>
</span></span><span style="display:flex;"><span>		ParameterExpression instance = Expression.Variable(<span style="color:#66d9ef">typeof</span>(T), <span style="color:#e6db74">&#34;instance&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//create a new instance of target type</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> block = <span style="color:#66d9ef">new</span> List&lt;Expression&gt;
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			Expression.Assign(instance, Expression.New(<span style="color:#66d9ef">typeof</span>(T).GetConstructors()[<span style="color:#ae81ff">0</span>]))
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> variables = <span style="color:#66d9ef">new</span> List&lt;ParameterExpression&gt; {instance};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all public and non-static properties</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> attrs = prop.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//validate an index from ArrayIndexAttribute</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> orderConst = Expression.Constant(order);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> orderCheck = Expression.LessThan(orderConst, Expression.ArrayLength(inputArray));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//set string property</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> stringPropertySet = Expression.Assign(
</span></span><span style="display:flex;"><span>					Expression.Property(instance, prop),
</span></span><span style="display:flex;"><span>					Expression.ArrayIndex(inputArray, orderConst));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				block.Add(Expression.IfThen(orderCheck, stringPropertySet));
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//get parser method from the list of available parsers (currently we parse only Int and DateTime)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (!TypeParsers.Parsers.TryGetValue(prop.PropertyType, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> parser))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> parseResult = Expression.Variable(prop.PropertyType, <span style="color:#e6db74">&#34;parseResult&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> parserCall = Expression.Call(parser, Expression.ArrayIndex(inputArray, orderConst), parseResult);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> propertySet = Expression.Assign(
</span></span><span style="display:flex;"><span>				Expression.Property(instance, prop),
</span></span><span style="display:flex;"><span>				parseResult);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//set property if an element of array is successfully parsed</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> ifSet = Expression.IfThen(parserCall, propertySet);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			block.Add(Expression.IfThen(orderCheck, ifSet));
</span></span><span style="display:flex;"><span>			variables.Add(parseResult);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		block.Add(instance);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//compile lambda expression into delegate</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> Expression.Lambda&lt;Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;&gt;(
</span></span><span style="display:flex;"><span>			Expression.Block(variables.ToArray(), Expression.Block(block)), 
</span></span><span style="display:flex;"><span>			inputArray).Compile();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="emit-il">Emit IL<a hidden class="anchor" aria-hidden="true" href="#emit-il">#</a></h3>
<p>Dotnet compiler transforms your C# code into intermediate language (<a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language">CIL or just IL</a>) and then dotnet runtime translates IL into machine instructions. For instance, using <a href="https://sharplab.io/">sharplab.io</a> you can easily check how generated IL will look like:
<img loading="lazy" src="/blog/posts/images/sharplab_msil.png" alt="C# and corresponding IL from https://sharplab.io/"  />
</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit?view=net-5.0">System.Reflection.Emit</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">How to: Define and Execute Dynamic Methods</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=netcore-3.1#fields">OpCodes list</a></li>
<li><a href="https://www.jetbrains.com/help/resharper/Viewing_Intermediate_Language.html">ReSharper IL viewer</a></li>
</ul>
<p>Here we are going to write (&ldquo;emit&rdquo;) IL instructions directly and then compile them into the delegate at runtime.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EmitIlParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> props = <span style="color:#66d9ef">typeof</span>(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> dm = <span style="color:#66d9ef">new</span> DynamicMethod(<span style="color:#e6db74">$&#34;from_{typeof(string[]).FullName}_to_{typeof(T).FullName}&#34;</span>, 
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">typeof</span>(T), <span style="color:#66d9ef">new</span> [] { <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>[]) }, <span style="color:#66d9ef">typeof</span>(EmitIlParserFactory).Module);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> il = dm.GetILGenerator();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//create a new instance of target type</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> instance = il.DeclareLocal(<span style="color:#66d9ef">typeof</span>(T));
</span></span><span style="display:flex;"><span>		il.Emit(OpCodes.Newobj, <span style="color:#66d9ef">typeof</span>(T).GetConstructors()[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>		il.Emit(OpCodes.Stloc, instance);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all public and non-static properties</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> attrs = prop.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> label = il.DefineLabel();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//check whether order from ArrayIndexAttribute is a valid index of the input array</span>
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldc_I4, order);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldarg_0);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldlen);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Bge_S, label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//set string property</span>
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldloc, instance);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldarg_0);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldc_I4, order);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldelem_Ref);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Callvirt, prop.GetSetMethod());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				il.MarkLabel(label);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//get parser method from the list of available parsers (currently we parse only Int and DateTime)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (!TypeParsers.Parsers.TryGetValue(prop.PropertyType, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> parser))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//check whether order from ArrayIndexAttribute is a valid index of the input array</span>
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldc_I4, order);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldarg_0);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldlen);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Bge_S, label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> parseResult = il.DeclareLocal(prop.PropertyType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldarg_0);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldc_I4, order);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldelem_Ref);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldloca, parseResult);
</span></span><span style="display:flex;"><span>			il.EmitCall(OpCodes.Call, parser, <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Brfalse_S, label);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//set property if an element of array is successfully parsed</span>
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldloc, instance);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldloc, parseResult);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Callvirt, prop.GetSetMethod());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.MarkLabel(label);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		il.Emit(OpCodes.Ldloc, instance);
</span></span><span style="display:flex;"><span>		il.Emit(OpCodes.Ret);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//create delegate from il instructions</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;)dm.CreateDelegate(<span style="color:#66d9ef">typeof</span>(Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="sigil">Sigil<a hidden class="anchor" aria-hidden="true" href="#sigil">#</a></h3>
<ul>
<li><a href="https://github.com/kevin-montrose/Sigil">A fail-fast validating helper for .NET CIL generation</a></li>
</ul>
<p>This approach is quite similar to the previous one, but now we use sigil which gives us a syntax sugar and more understandable error messages.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SigilParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> props = <span style="color:#66d9ef">typeof</span>(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> il = Emit&lt;Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;&gt;.NewDynamicMethod(<span style="color:#e6db74">$&#34;from_{typeof(string[]).FullName}_to_{typeof(T).FullName}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> instance = il.DeclareLocal&lt;T&gt;();
</span></span><span style="display:flex;"><span>		il.NewObject&lt;T&gt;();
</span></span><span style="display:flex;"><span>		il.StoreLocal(instance);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> attrs = prop.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> label = il.DefineLabel();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				il.LoadConstant(order);
</span></span><span style="display:flex;"><span>				il.LoadArgument(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>				il.LoadLength&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>				il.BranchIfGreaterOrEqual(label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				il.LoadLocal(instance);
</span></span><span style="display:flex;"><span>				il.LoadArgument(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>				il.LoadConstant(order);
</span></span><span style="display:flex;"><span>				il.LoadElement&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>				il.CallVirtual(prop.GetSetMethod());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				il.MarkLabel(label);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (!TypeParsers.Parsers.TryGetValue(prop.PropertyType, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> parser))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.LoadConstant(order);
</span></span><span style="display:flex;"><span>			il.LoadArgument(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>			il.LoadLength&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>			il.BranchIfGreaterOrEqual(label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> parseResult = il.DeclareLocal(prop.PropertyType);
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			il.LoadArgument(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>			il.LoadConstant(order);
</span></span><span style="display:flex;"><span>			il.LoadElement&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>			il.LoadLocalAddress(parseResult);
</span></span><span style="display:flex;"><span>			il.Call(parser);
</span></span><span style="display:flex;"><span>			il.BranchIfFalse(label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.LoadLocal(instance);
</span></span><span style="display:flex;"><span>			il.LoadLocal(parseResult);
</span></span><span style="display:flex;"><span>			il.CallVirtual(prop.GetSetMethod());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.MarkLabel(label);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		il.LoadLocal(instance);
</span></span><span style="display:flex;"><span>		il.Return();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> il.CreateDelegate();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="cache-compiled-parsers">Cache compiled parsers<a hidden class="anchor" aria-hidden="true" href="#cache-compiled-parsers">#</a></h3>
<p>We have implemented three approaches to create a parser delegate: expression tree, emit IL and sigil. In all cases we have the same problem: <code>IParserFactory.GetParser</code> does a hard job (builiding an expression tree or emitting IL and then creating delegate) every time you call it. Solution is quite simple - just cache it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CachedParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IParserFactory _realParserFactory;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ConcurrentDictionary&lt;<span style="color:#66d9ef">string</span>, Lazy&lt;<span style="color:#66d9ef">object</span>&gt;&gt; _cache;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> CachedParserFactory(IParserFactory realParserFactory)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		_realParserFactory = realParserFactory;
</span></span><span style="display:flex;"><span>		_cache = <span style="color:#66d9ef">new</span> ConcurrentDictionary&lt;<span style="color:#66d9ef">string</span>, Lazy&lt;<span style="color:#66d9ef">object</span>&gt;&gt;();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;)(_cache.GetOrAdd(<span style="color:#e6db74">$&#34;aip_{_realParserFactory.GetType().FullName}_{typeof(T).FullName}&#34;</span>, 
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">new</span> Lazy&lt;<span style="color:#66d9ef">object</span>&gt;(() =&gt; _realParserFactory.GetParser&lt;T&gt;(), LazyThreadSafetyMode.ExecutionAndPublication)).Value);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we reuse compiled versions of delegates which is more efficient.</p>
<h3 id="roslyn-based-approaches">Roslyn based approaches<a hidden class="anchor" aria-hidden="true" href="#roslyn-based-approaches">#</a></h3>
<p>Roslyn is a dotnet compiler platform which doesn&rsquo;t only compile code but gives an ability to do syntax analysis and to generate code.</p>
<h4 id="roslyn-runtime-code-generation">Roslyn runtime code generation<a hidden class="anchor" aria-hidden="true" href="#roslyn-runtime-code-generation">#</a></h4>
<ul>
<li><a href="https://gunnarpeipman.com/using-roslyn-to-build-object-to-object-mapper/amp/">Using Roslyn to build object to object mapper</a></li>
</ul>
<p>Roslyn approach is quite interesting because it gives an ability to write plain C# (as a string though) instead of writing IL instructions or combining  expression tree blocks:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RoslynParserInitializer</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IParserFactory CreateFactory()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//get all types marked with ParserOutputAttribute</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> targetTypes =
</span></span><span style="display:flex;"><span>            (<span style="color:#66d9ef">from</span> a <span style="color:#66d9ef">in</span> AppDomain.CurrentDomain.GetAssemblies()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">from</span> t <span style="color:#66d9ef">in</span> a.GetTypes()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> attributes = t.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ParserOutputAttribute), <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">where</span> attributes != <span style="color:#66d9ef">null</span> &amp;&amp; attributes.Length &gt; <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">select</span> t).ToArray();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> typeNames = <span style="color:#66d9ef">new</span> List&lt;(<span style="color:#66d9ef">string</span> TargetTypeName, <span style="color:#66d9ef">string</span> TargetTypeFullName, <span style="color:#66d9ef">string</span> TargetTypeParserName)&gt;();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> builder = <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>        builder.AppendLine(<span style="color:#e6db74">@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">using System;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">using Parsers.Common;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">public class RoslynGeneratedParserFactory : IParserFactory 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all types</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> targetType <span style="color:#66d9ef">in</span> targetTypes)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> targetTypeName = targetType.Name;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> targetTypeFullName = targetType.FullName;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> targetTypeParserName = targetTypeName + <span style="color:#e6db74">&#34;Parser&#34;</span>;
</span></span><span style="display:flex;"><span>            typeNames.Add((targetTypeName, targetTypeFullName, targetTypeParserName));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//generate private parser method for each target type</span>
</span></span><span style="display:flex;"><span>            builder.AppendLine(<span style="color:#e6db74">$&#34;private static T {targetTypeParserName}&lt;T&gt;(string[] input)&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">var {targetTypeName}Instance = new {targetTypeFullName}();&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> props = targetType.GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//go through all properties of the target type</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">var</span> attrs = prop.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = input[{order}];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">int</span>))
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length &amp;&amp; int.TryParse(input[{order}], out var parsed{prop.Name}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = parsed{prop.Name};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(DateTime))
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length &amp;&amp; DateTime.TryParse(input[{order}], out var parsed{prop.Name}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = parsed{prop.Name};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">object obj = {targetTypeName}Instance;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">return (T)obj;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        builder.AppendLine(<span style="color:#e6db74">&#34;public Func&lt;string[], T&gt; GetParser&lt;T&gt;() where T : new() {&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> typeName <span style="color:#66d9ef">in</span> typeNames)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if (typeof(T) == typeof({typeName.TargetTypeFullName}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">return {typeName.TargetTypeParserName}&lt;T&gt;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        builder.AppendLine(<span style="color:#e6db74">&#34;throw new NotSupportedException();}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        builder.AppendLine(<span style="color:#e6db74">&#34;}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> syntaxTree = CSharpSyntaxTree.ParseText(builder.ToString());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//reference assemblies</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">string</span> assemblyName = Path.GetRandomFileName();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> refPaths = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">string</span>&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(Object).GetTypeInfo().Assembly.Location,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(Enumerable).GetTypeInfo().Assembly.Location,
</span></span><span style="display:flex;"><span>            Path.Combine(Path.GetDirectoryName(<span style="color:#66d9ef">typeof</span>(GCSettings).GetTypeInfo().Assembly.Location), <span style="color:#e6db74">&#34;System.Runtime.dll&#34;</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(RoslynParserInitializer).GetTypeInfo().Assembly.Location,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(IParserFactory).GetTypeInfo().Assembly.Location,
</span></span><span style="display:flex;"><span>            Path.Combine(Path.GetDirectoryName(<span style="color:#66d9ef">typeof</span>(GCSettings).GetTypeInfo().Assembly.Location), <span style="color:#e6db74">&#34;netstandard.dll&#34;</span>),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        refPaths.AddRange(targetTypes.Select(x =&gt; x.Assembly.Location));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> references = refPaths.Select(r =&gt; MetadataReference.CreateFromFile(r)).ToArray();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// compile dynamic code</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> compilation = CSharpCompilation.Create(
</span></span><span style="display:flex;"><span>            assemblyName,
</span></span><span style="display:flex;"><span>            syntaxTrees: <span style="color:#66d9ef">new</span>[] { syntaxTree },
</span></span><span style="display:flex;"><span>            references: references,
</span></span><span style="display:flex;"><span>            options: <span style="color:#66d9ef">new</span> CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//compile assembly</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> (<span style="color:#66d9ef">var</span> ms = <span style="color:#66d9ef">new</span> MemoryStream())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> result = compilation.Emit(ms);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//to get a proper errors</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (!result.Success)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Exception(<span style="color:#66d9ef">string</span>.Join(<span style="color:#e6db74">&#34;,&#34;</span>, result.Diagnostics.Where(diagnostic =&gt;
</span></span><span style="display:flex;"><span>                    diagnostic.IsWarningAsError ||
</span></span><span style="display:flex;"><span>                    diagnostic.Severity == DiagnosticSeverity.Error).Select(x =&gt; x.GetMessage())));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ms.Seek(<span style="color:#ae81ff">0</span>, SeekOrigin.Begin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// load assembly from memory</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> assembly = AssemblyLoadContext.Default.LoadFromStream(ms);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> factoryType = assembly.GetType(<span style="color:#e6db74">&#34;RoslynGeneratedParserFactory&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (factoryType == <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullReferenceException(<span style="color:#e6db74">&#34;Roslyn generated parser type not found&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//create an instance of freshly generated parser factory</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (IParserFactory)Activator.CreateInstance(factoryType);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="source-generator">Source generator<a hidden class="anchor" aria-hidden="true" href="#source-generator">#</a></h4>
<ul>
<li>Overview of source generators from the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview">official documentation</a></li>
</ul>
<p>Source generator gives a very interesting ability of building parser&rsquo;s delegate during the compilation step, i.e. in advance. So in that case we don&rsquo;t have any runtime overhead to build a parser delegate at the first time which is amazing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[Generator]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ParserSourceGenerator</span> : ISourceGenerator
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Initialize(GeneratorInitializationContext context)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//uncomment to debug</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//System.Diagnostics.Debugger.Launch();</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Execute(GeneratorExecutionContext context)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> compilation = context.Compilation;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> parserOutputTypeSymbol = compilation.GetTypeByMetadataName(<span style="color:#e6db74">&#34;Parsers.Common.ParserOutputAttribute&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> attributeIndexTypeSymbol = compilation.GetTypeByMetadataName(<span style="color:#e6db74">&#34;Parsers.Common.ArrayIndexAttribute&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> typesToParse = <span style="color:#66d9ef">new</span> List&lt;ITypeSymbol&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> syntaxTree <span style="color:#66d9ef">in</span> compilation.SyntaxTrees)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> semanticModel = compilation.GetSemanticModel(syntaxTree);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//get all types marked with ParserOutputAttribute</span>
</span></span><span style="display:flex;"><span>			typesToParse.AddRange(syntaxTree.GetRoot()
</span></span><span style="display:flex;"><span>				.DescendantNodesAndSelf()
</span></span><span style="display:flex;"><span>				.OfType&lt;ClassDeclarationSyntax&gt;()
</span></span><span style="display:flex;"><span>				.Select(x =&gt; semanticModel.GetDeclaredSymbol(x))
</span></span><span style="display:flex;"><span>				.OfType&lt;ITypeSymbol&gt;()
</span></span><span style="display:flex;"><span>				.Where(x =&gt; x.GetAttributes().Select(a =&gt; a.AttributeClass)
</span></span><span style="display:flex;"><span>					.Any(b =&gt; b == parserOutputTypeSymbol)));
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> typeNames = <span style="color:#66d9ef">new</span> List&lt;(<span style="color:#66d9ef">string</span> TargetTypeName, <span style="color:#66d9ef">string</span> TargetTypeFullName, <span style="color:#66d9ef">string</span> TargetTypeParserName)&gt;();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> builder = <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>		builder.AppendLine(<span style="color:#e6db74">@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">using System;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">using Parsers.Common;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">namespace BySourceGenerator
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">public class Parser : IParserFactory 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all types</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> typeSymbol <span style="color:#66d9ef">in</span> typesToParse)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> targetTypeName = typeSymbol.Name;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> targetTypeFullName = GetFullName(typeSymbol);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> targetTypeParserName = targetTypeName + <span style="color:#e6db74">&#34;Parser&#34;</span>;
</span></span><span style="display:flex;"><span>			typeNames.Add((targetTypeName, targetTypeFullName, targetTypeParserName));
</span></span><span style="display:flex;"><span>			builder.AppendLine(<span style="color:#e6db74">$&#34;private static T {targetTypeParserName}&lt;T&gt;(string[] input)&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">var {targetTypeName}Instance = new {targetTypeFullName}();&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> props = typeSymbol.GetMembers().OfType&lt;IPropertySymbol&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//go through all properties of the target type</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> attr = prop.GetAttributes().FirstOrDefault(x =&gt; x.AttributeClass == attributeIndexTypeSymbol);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (attr == <span style="color:#66d9ef">null</span> || !(attr.ConstructorArguments[<span style="color:#ae81ff">0</span>].Value <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">int</span>)) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">int</span> order = (<span style="color:#66d9ef">int</span>) attr.ConstructorArguments[<span style="color:#ae81ff">0</span>].Value;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (GetFullName(prop.Type) == <span style="color:#e6db74">&#34;System.String&#34;</span>)
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = input[{order}];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (GetFullName(prop.Type) == <span style="color:#e6db74">&#34;System.Int32&#34;</span>)
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length &amp;&amp; int.TryParse(input[{order}], out var parsed{prop.Name}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = parsed{prop.Name};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (GetFullName(prop.Type) == <span style="color:#e6db74">&#34;System.DateTime&#34;</span>)
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length &amp;&amp; DateTime.TryParse(input[{order}], out var parsed{prop.Name}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = parsed{prop.Name};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">object obj = {targetTypeName}Instance;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">return (T)obj;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		builder.AppendLine(<span style="color:#e6db74">&#34;public Func&lt;string[], T&gt; GetParser&lt;T&gt;() where T : new() {&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> typeName <span style="color:#66d9ef">in</span> typeNames)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if (typeof(T) == typeof({typeName.TargetTypeFullName}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">return {typeName.TargetTypeParserName}&lt;T&gt;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		builder.AppendLine(<span style="color:#e6db74">&#34;throw new NotSupportedException();}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		builder.AppendLine(<span style="color:#e6db74">&#34;}}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> src = builder.ToString();
</span></span><span style="display:flex;"><span>		context.AddSource(
</span></span><span style="display:flex;"><span>			<span style="color:#e6db74">&#34;ParserGeneratedBySourceGenerator.cs&#34;</span>,
</span></span><span style="display:flex;"><span>			SourceText.From(src, Encoding.UTF8)
</span></span><span style="display:flex;"><span>		);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">string</span> GetFullName(ITypeSymbol typeSymbol) =&gt;
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">$&#34;{typeSymbol.ContainingNamespace}.{typeSymbol.Name}&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="benchmarks">Benchmarks<a hidden class="anchor" aria-hidden="true" href="#benchmarks">#</a></h2>
<p>The post wouldn&rsquo;t be comprehensive without benchmarks. I would like to compare two things:</p>
<ul>
<li>warm up step, i.e. generation of parser;</li>
<li>invocation of already generated parser.</li>
</ul>
<p>Benchmarks are measured using <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a>. <code>μs</code> - microsecond, <code>ns</code> - nanosecond, 1 μs = 1000 ns.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="generation-of-parser">Generation of parser<a hidden class="anchor" aria-hidden="true" href="#generation-of-parser">#</a></h3>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
<th style="text-align:right">Gen 0</th>
<th style="text-align:right">Gen 1</th>
<th style="text-align:right">Gen 2</th>
<th style="text-align:right">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>EmitIl</td>
<td style="text-align:right">22.02 μs</td>
<td style="text-align:right">0.495 μs</td>
<td style="text-align:right">1.429 μs</td>
<td style="text-align:right">1.2817</td>
<td style="text-align:right">0.6409</td>
<td style="text-align:right">0.0305</td>
<td style="text-align:right">5 KB</td>
</tr>
<tr>
<td>ExpressionTree</td>
<td style="text-align:right">683.68 μs</td>
<td style="text-align:right">13.609 μs</td>
<td style="text-align:right">31.268 μs</td>
<td style="text-align:right">2.9297</td>
<td style="text-align:right">0.9766</td>
<td style="text-align:right">-</td>
<td style="text-align:right">14 KB</td>
</tr>
<tr>
<td>Sigil</td>
<td style="text-align:right">642.63 μs</td>
<td style="text-align:right">12.305 μs</td>
<td style="text-align:right">29.243 μs</td>
<td style="text-align:right">112.3047</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">460 KB</td>
</tr>
<tr>
<td>Roslyn</td>
<td style="text-align:right">71,605.64 μs</td>
<td style="text-align:right">2,533.732 μs</td>
<td style="text-align:right">7,350.817 μs</td>
<td style="text-align:right">1000.0000</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">5,826 KB</td>
</tr>
</tbody>
</table>
<h3 id="invocation-of-parser">Invocation of parser<a hidden class="anchor" aria-hidden="true" href="#invocation-of-parser">#</a></h3>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
<th style="text-align:right">Ratio</th>
<th style="text-align:right">RatioSD</th>
<th style="text-align:right">Gen 0</th>
<th style="text-align:right">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>EmitIl</td>
<td style="text-align:right">374.7 ns</td>
<td style="text-align:right">7.75 ns</td>
<td style="text-align:right">22.36 ns</td>
<td style="text-align:right">1.02</td>
<td style="text-align:right">0.08</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>ExpressionTree</td>
<td style="text-align:right">378.1 ns</td>
<td style="text-align:right">7.56 ns</td>
<td style="text-align:right">20.57 ns</td>
<td style="text-align:right">1.03</td>
<td style="text-align:right">0.08</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>Reflection</td>
<td style="text-align:right">13,625.0 ns</td>
<td style="text-align:right">272.60 ns</td>
<td style="text-align:right">750.81 ns</td>
<td style="text-align:right">37.29</td>
<td style="text-align:right">2.29</td>
<td style="text-align:right">0.7782</td>
<td style="text-align:right">3,256 B</td>
</tr>
<tr>
<td>Sigil</td>
<td style="text-align:right">378.9 ns</td>
<td style="text-align:right">7.69 ns</td>
<td style="text-align:right">21.06 ns</td>
<td style="text-align:right">1.03</td>
<td style="text-align:right">0.07</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>Roslyn</td>
<td style="text-align:right">404.2 ns</td>
<td style="text-align:right">7.55 ns</td>
<td style="text-align:right">17.80 ns</td>
<td style="text-align:right">1.10</td>
<td style="text-align:right">0.07</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>SourceGenerator</td>
<td style="text-align:right">384.4 ns</td>
<td style="text-align:right">7.79 ns</td>
<td style="text-align:right">21.46 ns</td>
<td style="text-align:right">1.05</td>
<td style="text-align:right">0.08</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>ManuallyWritten</td>
<td style="text-align:right">367.8 ns</td>
<td style="text-align:right">7.36 ns</td>
<td style="text-align:right">15.68 ns</td>
<td style="text-align:right">1.00</td>
<td style="text-align:right">0.00</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
</tbody>
</table>
<p>All approaches besides direct usage of reflection give results almost identical to <a href="#plain-c">manually written C# parser</a>.</p>
<h2 id="source-code">Source code<a hidden class="anchor" aria-hidden="true" href="#source-code">#</a></h2>
<p>Here is <a href="https://github.com/MaximTkachenko/dotnet-code-generation-overview-by-example">github repository</a> with parser factories, unit tests and benchmarks.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://mtkachenko.me/blog/">Software engineering blog without title</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
