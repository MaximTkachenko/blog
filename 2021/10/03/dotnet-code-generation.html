<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Dotnet code generation overview by example - Software engineering blog without title</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Introduction Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Dotnet code generation overview by example" />
<meta property="og:description" content="Introduction Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mtkachenko.me/blog/2021/10/03/dotnet-code-generation.html" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-03T11:11:11+00:00" />
<meta property="article:modified_time" content="2021-10-03T11:11:11+00:00" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Dotnet code generation overview by example"/>
<meta name="twitter:description" content="Introduction Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc."/>

	
        <link href="https://mtkachenko.me/blog/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://mtkachenko.me/blog/css/main.fa747a9bb099b7bfd5d71b78a6e8ca2e23a425384e48bf533f1d357aeb61d265.css" />

	
	

	
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://mtkachenko.me/">Software engineering blog without title</a>
	</div>
	<nav>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Dotnet code generation overview by example</h1>
			<div class="meta">Posted on Oct 3, 2021</div>
		</div>
		

		

		<section class="body">
			<h2 id="introduction">Introduction</h2>
<p>Code generation is a very interesting topic. Instead of just writing code you can write code to write code. You can do code generation at compile time (new fancy source generators) and at runtime (expressions, emit IL). Anyway the idea to create methods and classes at runtime sounds like a magic to me. Runtime code generation feature is used quite heavily under the hood of DI frameworks, ORMs, different types of object mappers etc. Now when I have a sufficient understanding of the topic I realized that in the past I had some tasks which could be solved in more efficient and elegant way by using code generation. Unfortunately during those times I knew nothing about it. Searching the internet gave me results with quite high entry threshold and they didn&rsquo;t give an entire understanding of the feature. Most of examples in articles are quite trivial so it&rsquo;s still unclear how to apply it in practice. Here as the first step I want to describe a particular problem which could be solved with <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> and then to give an overview of different code generation approaches. There will be a lot of code.</p>
<h2 id="task-description">Task description</h2>
<p>Let&rsquo;s imagine our application receives a data from some source as an array of strings (for simplicity only string, integer and datetime values are expected in an input array):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>[<span style="color:#e6db74">&#34;John McClane&#34;</span>, <span style="color:#e6db74">&#34;1994-11-05T13:15:30&#34;</span>, <span style="color:#e6db74">&#34;4455&#34;</span>]
</span></span></code></pre></div><p>I need a generic way to parse this input into the instance of a particular class. This is an interface to create a parser delegate (i.e. it accepts an array of strings as the input and returns an instance of <code>T</code> as the output):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IParserFactory</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I use <code>ParserOutputAttribute</code> to identify classes used as parser&rsquo;s output. And I use <code>ArrayIndexAttribute</code> to understand which property corresponds to each of the array elements:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[ParserOutput]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Data</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [ArrayIndex(0)]</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } <span style="color:#75715e">// will be &#34;John McClane&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [ArrayIndex(2)]</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Number { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } <span style="color:#75715e">// will be 4455</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [ArrayIndex(1)]</span> <span style="color:#66d9ef">public</span> DateTime Birthday { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } <span style="color:#75715e">// will be 1994-11-05T13:15:30</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If array element can&rsquo;t be parsed to the target type then it&rsquo;s ignored.
So as a general idea I don&rsquo;t want to limit implementation by <code>Data</code> class only. I want to produce a parser delegate for any type with the proper attributes.</p>
<h2 id="plain-c">Plain C#</h2>
<p>First of all I want to write a plain C# code without code generation or reflection at all for a known type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> data = <span style="color:#66d9ef">new</span> Data();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> &lt; inputArray.Length)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    data.Name = inputArray[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">1</span> &lt; inputArray.Length &amp;&amp; DateTime.TryParse(inputArray[<span style="color:#ae81ff">1</span>], <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> bd))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    data.Birthday = bd;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">2</span> &lt; inputArray.Length &amp;&amp; <span style="color:#66d9ef">int</span>.TryParse(inputArray[<span style="color:#ae81ff">2</span>], <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> n))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    data.Number = n;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> data;
</span></span></code></pre></div><p>Quite simple, right? But now I want to generate the same code for an arbitrary type at runtime or compile time. Let&rsquo;s go!</p>
<h2 id="reflection">Reflection</h2>
<p>In the first approach with <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection">reflection</a> I&rsquo;m not going to generate a parser delegate. Instead I&rsquo;m going to create an instance of the target type and set its properties using reflection API.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReflectionParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ArrayIndexParse&lt;T&gt;;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> T ArrayIndexParse&lt;T&gt;(<span style="color:#66d9ef">string</span>[] data) <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// create a new instance of target type</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> instance = <span style="color:#66d9ef">new</span> T();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> props = <span style="color:#66d9ef">typeof</span>(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all public and non-static properties</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//read and parse corresponding element in array and if success - set property value</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; props.Length; i++)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> attrs = props[i].GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span> || order &gt;= data.Length) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (props[i].PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				props[i].SetValue(instance, data[order]);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (props[i].PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">int</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">int</span>.TryParse(data[order], <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> intResult))
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					props[i].SetValue(instance, intResult);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (props[i].PropertyType == <span style="color:#66d9ef">typeof</span>(DateTime))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (DateTime.TryParse(data[order], <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> dtResult))
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					props[i].SetValue(instance, dtResult);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> instance;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It works and it&rsquo;s quite readable. But it&rsquo;s <a href="https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/">slow</a> (check <a href="#benchmarks">benchmarks</a> section below too). If you want to call this code very often it could be an issue. I want to implement something more sophisticated using <strong>real</strong> code generation.</p>
<h2 id="code-generation">Code generation</h2>
<h3 id="expression-trees">Expression trees</h3>
<p>From the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/">official documentation</a>:</p>
<blockquote>
<p>Expression trees represent code in a tree-like data structure, where each node is an expression, for example, a method call or a binary operation such as x &lt; y. You can compile and run code represented by expression trees.</p>
</blockquote>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-execute-expression-trees">How to execute expression trees</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions?view=netcore-3.1#classes">Expression classes</a></li>
</ul>
<p>Expression trees give primitive building blocks like <code>Expression.Call</code> to call a method, <code>Expression.Loop</code> to add some repeating logic etc. Then using these blocks we build a parser delegate as a <code>tree</code> of instructions and finally compile it into the delegate at runtime.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExpressionTreeParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> props = <span style="color:#66d9ef">typeof</span>(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//declare an input parameter of the delegate</span>
</span></span><span style="display:flex;"><span>		ParameterExpression inputArray = Expression.Parameter(<span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>[]), <span style="color:#e6db74">&#34;inputArray&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//declare an output parameter of the delegate</span>
</span></span><span style="display:flex;"><span>		ParameterExpression instance = Expression.Variable(<span style="color:#66d9ef">typeof</span>(T), <span style="color:#e6db74">&#34;instance&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//create a new instance of target type</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> block = <span style="color:#66d9ef">new</span> List&lt;Expression&gt;
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			Expression.Assign(instance, Expression.New(<span style="color:#66d9ef">typeof</span>(T).GetConstructors()[<span style="color:#ae81ff">0</span>]))
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> variables = <span style="color:#66d9ef">new</span> List&lt;ParameterExpression&gt; {instance};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all public and non-static properties</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> attrs = prop.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//validate an index from ArrayIndexAttribute</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> orderConst = Expression.Constant(order);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> orderCheck = Expression.LessThan(orderConst, Expression.ArrayLength(inputArray));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//set string property</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> stringPropertySet = Expression.Assign(
</span></span><span style="display:flex;"><span>					Expression.Property(instance, prop),
</span></span><span style="display:flex;"><span>					Expression.ArrayIndex(inputArray, orderConst));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				block.Add(Expression.IfThen(orderCheck, stringPropertySet));
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//get parser method from the list of available parsers (currently we parse only Int and DateTime)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (!TypeParsers.Parsers.TryGetValue(prop.PropertyType, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> parser))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> parseResult = Expression.Variable(prop.PropertyType, <span style="color:#e6db74">&#34;parseResult&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> parserCall = Expression.Call(parser, Expression.ArrayIndex(inputArray, orderConst), parseResult);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> propertySet = Expression.Assign(
</span></span><span style="display:flex;"><span>				Expression.Property(instance, prop),
</span></span><span style="display:flex;"><span>				parseResult);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//set property if an element of array is successfully parsed</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> ifSet = Expression.IfThen(parserCall, propertySet);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			block.Add(Expression.IfThen(orderCheck, ifSet));
</span></span><span style="display:flex;"><span>			variables.Add(parseResult);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		block.Add(instance);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//compile lambda expression into delegate</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> Expression.Lambda&lt;Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;&gt;(
</span></span><span style="display:flex;"><span>			Expression.Block(variables.ToArray(), Expression.Block(block)), 
</span></span><span style="display:flex;"><span>			inputArray).Compile();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="emit-il">Emit IL</h3>
<p>Dotnet compiler transforms your C# code into intermediate language (<a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language">CIL or just IL</a>) and then dotnet runtime translates IL into machine instructions. For instance, using <a href="https://sharplab.io/">sharplab.io</a> you can easily check how generated IL will look like:
<img src="/blog/posts/images/sharplab_msil.png" alt="C# and corresponding IL from https://sharplab.io/"></p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit?view=net-5.0">System.Reflection.Emit</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods">How to: Define and Execute Dynamic Methods</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=netcore-3.1#fields">OpCodes list</a></li>
<li><a href="https://www.jetbrains.com/help/resharper/Viewing_Intermediate_Language.html">ReSharper IL viewer</a></li>
</ul>
<p>Here we are going to write (&ldquo;emit&rdquo;) IL instructions directly and then compile them into the delegate at runtime.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EmitIlParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> props = <span style="color:#66d9ef">typeof</span>(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> dm = <span style="color:#66d9ef">new</span> DynamicMethod(<span style="color:#e6db74">$&#34;from_{typeof(string[]).FullName}_to_{typeof(T).FullName}&#34;</span>, 
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">typeof</span>(T), <span style="color:#66d9ef">new</span> [] { <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>[]) }, <span style="color:#66d9ef">typeof</span>(EmitIlParserFactory).Module);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> il = dm.GetILGenerator();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//create a new instance of target type</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> instance = il.DeclareLocal(<span style="color:#66d9ef">typeof</span>(T));
</span></span><span style="display:flex;"><span>		il.Emit(OpCodes.Newobj, <span style="color:#66d9ef">typeof</span>(T).GetConstructors()[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>		il.Emit(OpCodes.Stloc, instance);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all public and non-static properties</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> attrs = prop.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> label = il.DefineLabel();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//check whether order from ArrayIndexAttribute is a valid index of the input array</span>
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldc_I4, order);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldarg_0);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldlen);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Bge_S, label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//set string property</span>
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldloc, instance);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldarg_0);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldc_I4, order);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Ldelem_Ref);
</span></span><span style="display:flex;"><span>				il.Emit(OpCodes.Callvirt, prop.GetSetMethod());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				il.MarkLabel(label);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//get parser method from the list of available parsers (currently we parse only Int and DateTime)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (!TypeParsers.Parsers.TryGetValue(prop.PropertyType, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> parser))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//check whether order from ArrayIndexAttribute is a valid index of the input array</span>
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldc_I4, order);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldarg_0);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldlen);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Bge_S, label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> parseResult = il.DeclareLocal(prop.PropertyType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldarg_0);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldc_I4, order);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldelem_Ref);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldloca, parseResult);
</span></span><span style="display:flex;"><span>			il.EmitCall(OpCodes.Call, parser, <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Brfalse_S, label);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//set property if an element of array is successfully parsed</span>
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldloc, instance);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Ldloc, parseResult);
</span></span><span style="display:flex;"><span>			il.Emit(OpCodes.Callvirt, prop.GetSetMethod());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.MarkLabel(label);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		il.Emit(OpCodes.Ldloc, instance);
</span></span><span style="display:flex;"><span>		il.Emit(OpCodes.Ret);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//create delegate from il instructions</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;)dm.CreateDelegate(<span style="color:#66d9ef">typeof</span>(Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="sigil">Sigil</h3>
<ul>
<li><a href="https://github.com/kevin-montrose/Sigil">A fail-fast validating helper for .NET CIL generation</a></li>
</ul>
<p>This approach is quite similar to the previous one, but now we use sigil which gives us a syntax sugar and more understandable error messages.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SigilParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> props = <span style="color:#66d9ef">typeof</span>(T).GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> il = Emit&lt;Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;&gt;.NewDynamicMethod(<span style="color:#e6db74">$&#34;from_{typeof(string[]).FullName}_to_{typeof(T).FullName}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> instance = il.DeclareLocal&lt;T&gt;();
</span></span><span style="display:flex;"><span>		il.NewObject&lt;T&gt;();
</span></span><span style="display:flex;"><span>		il.StoreLocal(instance);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> attrs = prop.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> label = il.DefineLabel();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				il.LoadConstant(order);
</span></span><span style="display:flex;"><span>				il.LoadArgument(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>				il.LoadLength&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>				il.BranchIfGreaterOrEqual(label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				il.LoadLocal(instance);
</span></span><span style="display:flex;"><span>				il.LoadArgument(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>				il.LoadConstant(order);
</span></span><span style="display:flex;"><span>				il.LoadElement&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>				il.CallVirtual(prop.GetSetMethod());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				il.MarkLabel(label);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (!TypeParsers.Parsers.TryGetValue(prop.PropertyType, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> parser))
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.LoadConstant(order);
</span></span><span style="display:flex;"><span>			il.LoadArgument(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>			il.LoadLength&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>			il.BranchIfGreaterOrEqual(label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> parseResult = il.DeclareLocal(prop.PropertyType);
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			il.LoadArgument(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>			il.LoadConstant(order);
</span></span><span style="display:flex;"><span>			il.LoadElement&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>			il.LoadLocalAddress(parseResult);
</span></span><span style="display:flex;"><span>			il.Call(parser);
</span></span><span style="display:flex;"><span>			il.BranchIfFalse(label);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.LoadLocal(instance);
</span></span><span style="display:flex;"><span>			il.LoadLocal(parseResult);
</span></span><span style="display:flex;"><span>			il.CallVirtual(prop.GetSetMethod());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			il.MarkLabel(label);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		il.LoadLocal(instance);
</span></span><span style="display:flex;"><span>		il.Return();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> il.CreateDelegate();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="cache-compiled-parsers">Cache compiled parsers</h3>
<p>We have implemented three approaches to create a parser delegate: expression tree, emit IL and sigil. In all cases we have the same problem: <code>IParserFactory.GetParser</code> does a hard job (builiding an expression tree or emitting IL and then creating delegate) every time you call it. Solution is quite simple - just cache it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CachedParserFactory</span> : IParserFactory
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IParserFactory _realParserFactory;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ConcurrentDictionary&lt;<span style="color:#66d9ef">string</span>, Lazy&lt;<span style="color:#66d9ef">object</span>&gt;&gt; _cache;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> CachedParserFactory(IParserFactory realParserFactory)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		_realParserFactory = realParserFactory;
</span></span><span style="display:flex;"><span>		_cache = <span style="color:#66d9ef">new</span> ConcurrentDictionary&lt;<span style="color:#66d9ef">string</span>, Lazy&lt;<span style="color:#66d9ef">object</span>&gt;&gt;();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Func&lt;<span style="color:#66d9ef">string</span>[], T&gt; GetParser&lt;T&gt;() <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (Func&lt;<span style="color:#66d9ef">string</span>[], T&gt;)(_cache.GetOrAdd(<span style="color:#e6db74">$&#34;aip_{_realParserFactory.GetType().FullName}_{typeof(T).FullName}&#34;</span>, 
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">new</span> Lazy&lt;<span style="color:#66d9ef">object</span>&gt;(() =&gt; _realParserFactory.GetParser&lt;T&gt;(), LazyThreadSafetyMode.ExecutionAndPublication)).Value);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we reuse compiled versions of delegates which is more efficient.</p>
<h3 id="roslyn-based-approaches">Roslyn based approaches</h3>
<p>Roslyn is a dotnet compiler platform which doesn&rsquo;t only compile code but gives an ability to do syntax analysis and to generate code.</p>
<h4 id="roslyn-runtime-code-generation">Roslyn runtime code generation</h4>
<ul>
<li><a href="https://gunnarpeipman.com/using-roslyn-to-build-object-to-object-mapper/amp/">Using Roslyn to build object to object mapper</a></li>
</ul>
<p>Roslyn approach is quite interesting because it gives an ability to write plain C# (as a string though) instead of writing IL instructions or combining  expression tree blocks:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RoslynParserInitializer</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IParserFactory CreateFactory()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//get all types marked with ParserOutputAttribute</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> targetTypes =
</span></span><span style="display:flex;"><span>            (<span style="color:#66d9ef">from</span> a <span style="color:#66d9ef">in</span> AppDomain.CurrentDomain.GetAssemblies()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">from</span> t <span style="color:#66d9ef">in</span> a.GetTypes()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> attributes = t.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ParserOutputAttribute), <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">where</span> attributes != <span style="color:#66d9ef">null</span> &amp;&amp; attributes.Length &gt; <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">select</span> t).ToArray();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> typeNames = <span style="color:#66d9ef">new</span> List&lt;(<span style="color:#66d9ef">string</span> TargetTypeName, <span style="color:#66d9ef">string</span> TargetTypeFullName, <span style="color:#66d9ef">string</span> TargetTypeParserName)&gt;();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> builder = <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>        builder.AppendLine(<span style="color:#e6db74">@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">using System;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">using Parsers.Common;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">public class RoslynGeneratedParserFactory : IParserFactory 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all types</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> targetType <span style="color:#66d9ef">in</span> targetTypes)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> targetTypeName = targetType.Name;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> targetTypeFullName = targetType.FullName;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> targetTypeParserName = targetTypeName + <span style="color:#e6db74">&#34;Parser&#34;</span>;
</span></span><span style="display:flex;"><span>            typeNames.Add((targetTypeName, targetTypeFullName, targetTypeParserName));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//generate private parser method for each target type</span>
</span></span><span style="display:flex;"><span>            builder.AppendLine(<span style="color:#e6db74">$&#34;private static T {targetTypeParserName}&lt;T&gt;(string[] input)&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">var {targetTypeName}Instance = new {targetTypeFullName}();&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> props = targetType.GetProperties(BindingFlags.Instance | BindingFlags.Public);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//go through all properties of the target type</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">var</span> attrs = prop.GetCustomAttributes(<span style="color:#66d9ef">typeof</span>(ArrayIndexAttribute)).ToArray();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (attrs.Length == <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> order = ((ArrayIndexAttribute)attrs[<span style="color:#ae81ff">0</span>]).Order;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">string</span>))
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = input[{order}];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">int</span>))
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length &amp;&amp; int.TryParse(input[{order}], out var parsed{prop.Name}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = parsed{prop.Name};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (prop.PropertyType == <span style="color:#66d9ef">typeof</span>(DateTime))
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length &amp;&amp; DateTime.TryParse(input[{order}], out var parsed{prop.Name}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = parsed{prop.Name};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">object obj = {targetTypeName}Instance;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">return (T)obj;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        builder.AppendLine(<span style="color:#e6db74">&#34;public Func&lt;string[], T&gt; GetParser&lt;T&gt;() where T : new() {&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> typeName <span style="color:#66d9ef">in</span> typeNames)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if (typeof(T) == typeof({typeName.TargetTypeFullName}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">return {typeName.TargetTypeParserName}&lt;T&gt;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        builder.AppendLine(<span style="color:#e6db74">&#34;throw new NotSupportedException();}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        builder.AppendLine(<span style="color:#e6db74">&#34;}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> syntaxTree = CSharpSyntaxTree.ParseText(builder.ToString());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//reference assemblies</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">string</span> assemblyName = Path.GetRandomFileName();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> refPaths = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">string</span>&gt; {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(Object).GetTypeInfo().Assembly.Location,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(Enumerable).GetTypeInfo().Assembly.Location,
</span></span><span style="display:flex;"><span>            Path.Combine(Path.GetDirectoryName(<span style="color:#66d9ef">typeof</span>(GCSettings).GetTypeInfo().Assembly.Location), <span style="color:#e6db74">&#34;System.Runtime.dll&#34;</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(RoslynParserInitializer).GetTypeInfo().Assembly.Location,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(IParserFactory).GetTypeInfo().Assembly.Location,
</span></span><span style="display:flex;"><span>            Path.Combine(Path.GetDirectoryName(<span style="color:#66d9ef">typeof</span>(GCSettings).GetTypeInfo().Assembly.Location), <span style="color:#e6db74">&#34;netstandard.dll&#34;</span>),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        refPaths.AddRange(targetTypes.Select(x =&gt; x.Assembly.Location));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> references = refPaths.Select(r =&gt; MetadataReference.CreateFromFile(r)).ToArray();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// compile dynamic code</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> compilation = CSharpCompilation.Create(
</span></span><span style="display:flex;"><span>            assemblyName,
</span></span><span style="display:flex;"><span>            syntaxTrees: <span style="color:#66d9ef">new</span>[] { syntaxTree },
</span></span><span style="display:flex;"><span>            references: references,
</span></span><span style="display:flex;"><span>            options: <span style="color:#66d9ef">new</span> CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//compile assembly</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> (<span style="color:#66d9ef">var</span> ms = <span style="color:#66d9ef">new</span> MemoryStream())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> result = compilation.Emit(ms);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//to get a proper errors</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (!result.Success)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Exception(<span style="color:#66d9ef">string</span>.Join(<span style="color:#e6db74">&#34;,&#34;</span>, result.Diagnostics.Where(diagnostic =&gt;
</span></span><span style="display:flex;"><span>                    diagnostic.IsWarningAsError ||
</span></span><span style="display:flex;"><span>                    diagnostic.Severity == DiagnosticSeverity.Error).Select(x =&gt; x.GetMessage())));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ms.Seek(<span style="color:#ae81ff">0</span>, SeekOrigin.Begin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// load assembly from memory</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> assembly = AssemblyLoadContext.Default.LoadFromStream(ms);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> factoryType = assembly.GetType(<span style="color:#e6db74">&#34;RoslynGeneratedParserFactory&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (factoryType == <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullReferenceException(<span style="color:#e6db74">&#34;Roslyn generated parser type not found&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//create an instance of freshly generated parser factory</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (IParserFactory)Activator.CreateInstance(factoryType);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="source-generator">Source generator</h4>
<ul>
<li>Overview of source generators from the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview">official documentation</a></li>
</ul>
<p>Source generator gives a very interesting ability of building parser&rsquo;s delegate during the compilation step, i.e. in advance. So in that case we don&rsquo;t have any runtime overhead to build a parser delegate at the first time which is amazing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[Generator]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ParserSourceGenerator</span> : ISourceGenerator
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Initialize(GeneratorInitializationContext context)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//uncomment to debug</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//System.Diagnostics.Debugger.Launch();</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Execute(GeneratorExecutionContext context)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> compilation = context.Compilation;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> parserOutputTypeSymbol = compilation.GetTypeByMetadataName(<span style="color:#e6db74">&#34;Parsers.Common.ParserOutputAttribute&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> attributeIndexTypeSymbol = compilation.GetTypeByMetadataName(<span style="color:#e6db74">&#34;Parsers.Common.ArrayIndexAttribute&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> typesToParse = <span style="color:#66d9ef">new</span> List&lt;ITypeSymbol&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> syntaxTree <span style="color:#66d9ef">in</span> compilation.SyntaxTrees)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> semanticModel = compilation.GetSemanticModel(syntaxTree);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//get all types marked with ParserOutputAttribute</span>
</span></span><span style="display:flex;"><span>			typesToParse.AddRange(syntaxTree.GetRoot()
</span></span><span style="display:flex;"><span>				.DescendantNodesAndSelf()
</span></span><span style="display:flex;"><span>				.OfType&lt;ClassDeclarationSyntax&gt;()
</span></span><span style="display:flex;"><span>				.Select(x =&gt; semanticModel.GetDeclaredSymbol(x))
</span></span><span style="display:flex;"><span>				.OfType&lt;ITypeSymbol&gt;()
</span></span><span style="display:flex;"><span>				.Where(x =&gt; x.GetAttributes().Select(a =&gt; a.AttributeClass)
</span></span><span style="display:flex;"><span>					.Any(b =&gt; b == parserOutputTypeSymbol)));
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> typeNames = <span style="color:#66d9ef">new</span> List&lt;(<span style="color:#66d9ef">string</span> TargetTypeName, <span style="color:#66d9ef">string</span> TargetTypeFullName, <span style="color:#66d9ef">string</span> TargetTypeParserName)&gt;();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> builder = <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>		builder.AppendLine(<span style="color:#e6db74">@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">using System;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">using Parsers.Common;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">namespace BySourceGenerator
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">public class Parser : IParserFactory 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//go through all types</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> typeSymbol <span style="color:#66d9ef">in</span> typesToParse)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> targetTypeName = typeSymbol.Name;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> targetTypeFullName = GetFullName(typeSymbol);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> targetTypeParserName = targetTypeName + <span style="color:#e6db74">&#34;Parser&#34;</span>;
</span></span><span style="display:flex;"><span>			typeNames.Add((targetTypeName, targetTypeFullName, targetTypeParserName));
</span></span><span style="display:flex;"><span>			builder.AppendLine(<span style="color:#e6db74">$&#34;private static T {targetTypeParserName}&lt;T&gt;(string[] input)&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">var {targetTypeName}Instance = new {targetTypeFullName}();&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> props = typeSymbol.GetMembers().OfType&lt;IPropertySymbol&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//go through all properties of the target type</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> prop <span style="color:#66d9ef">in</span> props)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> attr = prop.GetAttributes().FirstOrDefault(x =&gt; x.AttributeClass == attributeIndexTypeSymbol);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (attr == <span style="color:#66d9ef">null</span> || !(attr.ConstructorArguments[<span style="color:#ae81ff">0</span>].Value <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">int</span>)) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">int</span> order = (<span style="color:#66d9ef">int</span>) attr.ConstructorArguments[<span style="color:#ae81ff">0</span>].Value;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (order &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (GetFullName(prop.Type) == <span style="color:#e6db74">&#34;System.String&#34;</span>)
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = input[{order}];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (GetFullName(prop.Type) == <span style="color:#e6db74">&#34;System.Int32&#34;</span>)
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length &amp;&amp; int.TryParse(input[{order}], out var parsed{prop.Name}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = parsed{prop.Name};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (GetFullName(prop.Type) == <span style="color:#e6db74">&#34;System.DateTime&#34;</span>)
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if({order} &lt; input.Length &amp;&amp; DateTime.TryParse(input[{order}], out var parsed{prop.Name}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{targetTypeName}Instance.{prop.Name} = parsed{prop.Name};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">object obj = {targetTypeName}Instance;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">return (T)obj;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		builder.AppendLine(<span style="color:#e6db74">&#34;public Func&lt;string[], T&gt; GetParser&lt;T&gt;() where T : new() {&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> typeName <span style="color:#66d9ef">in</span> typeNames)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			builder.Append(<span style="color:#e6db74">$@&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if (typeof(T) == typeof({typeName.TargetTypeFullName}))
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">return {typeName.TargetTypeParserName}&lt;T&gt;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		builder.AppendLine(<span style="color:#e6db74">&#34;throw new NotSupportedException();}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		builder.AppendLine(<span style="color:#e6db74">&#34;}}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> src = builder.ToString();
</span></span><span style="display:flex;"><span>		context.AddSource(
</span></span><span style="display:flex;"><span>			<span style="color:#e6db74">&#34;ParserGeneratedBySourceGenerator.cs&#34;</span>,
</span></span><span style="display:flex;"><span>			SourceText.From(src, Encoding.UTF8)
</span></span><span style="display:flex;"><span>		);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">string</span> GetFullName(ITypeSymbol typeSymbol) =&gt;
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">$&#34;{typeSymbol.ContainingNamespace}.{typeSymbol.Name}&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="benchmarks">Benchmarks</h2>
<p>The post wouldn&rsquo;t be comprehensive without benchmarks. I would like to compare two things:</p>
<ul>
<li>warm up step, i.e. generation of parser;</li>
<li>invocation of already generated parser.</li>
</ul>
<p>Benchmarks are measured using <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a>. <code>s</code> - microsecond, <code>ns</code> - nanosecond, 1 s = 1000 ns.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="generation-of-parser">Generation of parser</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
<th style="text-align:right">Gen 0</th>
<th style="text-align:right">Gen 1</th>
<th style="text-align:right">Gen 2</th>
<th style="text-align:right">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>EmitIl</td>
<td style="text-align:right">22.02 s</td>
<td style="text-align:right">0.495 s</td>
<td style="text-align:right">1.429 s</td>
<td style="text-align:right">1.2817</td>
<td style="text-align:right">0.6409</td>
<td style="text-align:right">0.0305</td>
<td style="text-align:right">5 KB</td>
</tr>
<tr>
<td>ExpressionTree</td>
<td style="text-align:right">683.68 s</td>
<td style="text-align:right">13.609 s</td>
<td style="text-align:right">31.268 s</td>
<td style="text-align:right">2.9297</td>
<td style="text-align:right">0.9766</td>
<td style="text-align:right">-</td>
<td style="text-align:right">14 KB</td>
</tr>
<tr>
<td>Sigil</td>
<td style="text-align:right">642.63 s</td>
<td style="text-align:right">12.305 s</td>
<td style="text-align:right">29.243 s</td>
<td style="text-align:right">112.3047</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">460 KB</td>
</tr>
<tr>
<td>Roslyn</td>
<td style="text-align:right">71,605.64 s</td>
<td style="text-align:right">2,533.732 s</td>
<td style="text-align:right">7,350.817 s</td>
<td style="text-align:right">1000.0000</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">5,826 KB</td>
</tr>
</tbody>
</table>
<h3 id="invocation-of-parser">Invocation of parser</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
<th style="text-align:right">Ratio</th>
<th style="text-align:right">RatioSD</th>
<th style="text-align:right">Gen 0</th>
<th style="text-align:right">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>EmitIl</td>
<td style="text-align:right">374.7 ns</td>
<td style="text-align:right">7.75 ns</td>
<td style="text-align:right">22.36 ns</td>
<td style="text-align:right">1.02</td>
<td style="text-align:right">0.08</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>ExpressionTree</td>
<td style="text-align:right">378.1 ns</td>
<td style="text-align:right">7.56 ns</td>
<td style="text-align:right">20.57 ns</td>
<td style="text-align:right">1.03</td>
<td style="text-align:right">0.08</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>Reflection</td>
<td style="text-align:right">13,625.0 ns</td>
<td style="text-align:right">272.60 ns</td>
<td style="text-align:right">750.81 ns</td>
<td style="text-align:right">37.29</td>
<td style="text-align:right">2.29</td>
<td style="text-align:right">0.7782</td>
<td style="text-align:right">3,256 B</td>
</tr>
<tr>
<td>Sigil</td>
<td style="text-align:right">378.9 ns</td>
<td style="text-align:right">7.69 ns</td>
<td style="text-align:right">21.06 ns</td>
<td style="text-align:right">1.03</td>
<td style="text-align:right">0.07</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>Roslyn</td>
<td style="text-align:right">404.2 ns</td>
<td style="text-align:right">7.55 ns</td>
<td style="text-align:right">17.80 ns</td>
<td style="text-align:right">1.10</td>
<td style="text-align:right">0.07</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>SourceGenerator</td>
<td style="text-align:right">384.4 ns</td>
<td style="text-align:right">7.79 ns</td>
<td style="text-align:right">21.46 ns</td>
<td style="text-align:right">1.05</td>
<td style="text-align:right">0.08</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
<tr>
<td>ManuallyWritten</td>
<td style="text-align:right">367.8 ns</td>
<td style="text-align:right">7.36 ns</td>
<td style="text-align:right">15.68 ns</td>
<td style="text-align:right">1.00</td>
<td style="text-align:right">0.00</td>
<td style="text-align:right">0.0095</td>
<td style="text-align:right">40 B</td>
</tr>
</tbody>
</table>
<p>All approaches besides direct usage of reflection give results almost identical to <a href="#plain-c">manually written C# parser</a>.</p>
<h2 id="source-code">Source code</h2>
<p>Here is <a href="https://github.com/MaximTkachenko/dotnet-code-generation-overview-by-example">github repository</a> with parser factories, unit tests and benchmarks.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/dotnet">dotnet</a></li>
					
					<li><a href="/tags/code-generation">code generation</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2024  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


</div>
    </body>
</html>
